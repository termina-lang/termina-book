{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The Termina Book","text":"<p>Welcome to the documentation for the Termina Programming Language.</p>"},{"location":"foreword/","title":"Foreword","text":"<p>Software has become the invisible backbone of spacecraft, aircraft, satellites, cars, and medical devices. These are systems where failure is not an option, where correctness, safety, and predictability matter more than raw performance or convenience. However, most of the tools we use to build such systems were not designed with these constraints in mind.  </p> <p>The Termina programming language was created to address this shortcoming. It is a language designed from scratch for critical real-time reactive embedded systems.</p> <ul> <li>Reactive programming model: Software developed in Termina is structured around actions that are executed in response to both synchronous and asynchronous events. The language provides its own elements for expressing concurrency, such as tasks and handlers, as well as message queues for interconnecting active elements. It also provides shared resources that allow procedures to be defined and data to be accessed, in mutual exclusion, ensuring that there are no deadlocks by design.</li> <li>Determinism: When developing real-time critical systems, it is crucial to apply design techniques and methodologies that allow verification that the real-time requirements imposed on software applications are met. Therefore, it is necessary to ensure that the developed system is deterministic and predictable. By design, the Termina language forces responses to events always to be finite, limiting the number of loop iterations and prohibiting recursion, and facilitating subsequent analysis and the obtention and measurement of the worst response times for the different sequences of actions in response to events.</li> <li>Memory safety guarantees: the Termina language ensures the absence of memory errors such as null pointer dereferencing, use-after-free errors, and memory leaks, as well as other errors such as out-of-bounds array indexing. Dynamic memory management is carried out deterministically through the use of built-in memory pools.</li> </ul> <p>This book introduces Termina step by step. It assumes you are comfortable with programming in languages like C, Ada, or Rust, but not necessarily an expert in embedded real-time systems. Our goal is not only to teach you Termina as a language, but also to encourage a way of thinking about programming where safety and reliability are the default.  If you come from a background in C, you may find the restrictions unusual at first. If you are familiar with Ada/SPARK or Rust, you may recognize shared ideas but notice Termina's simpler, domain-specific design. Either way, as you progress, you will see how these design choices are not limitations but tools that enable more robust systems.  </p> <p>Whether you are a student, a researcher, or an engineer working on real-time embedded platforms, this book is your entry point into Termina. It will give you both the practical skills to write Termina programs and the conceptual understanding to reason about their safety.</p> <p>Welcome to Termina. Let\u2019s build systems we can trust.</p>"},{"location":"tutorial/","title":"Building our first application","text":""},{"location":"tutorial/#introduction","title":"Introduction","text":"<p>This section presents a complete example of an application developed in Termina, illustrating the combined use of the language\u2019s primary constructs: resources, tasks, emitters, handlers, message queues, and memory pools.</p> <p>The goal is to implement a simplified version of the application software of a generic on-board satellite Instrument Control Unit (ICU). In this example, the software will perform two specific functions:</p> <ul> <li> <p>Housekeeping subsystem: The housekeeping subsystem is responsible for the periodic monitoring of the instrument\u2019s internal state. It collects engineering parameters such as voltages, currents, and internal status flags, aggregates them into data packets, and makes them available for transmission to the spacecraft platform. In this tutorial, this functionality will be emulated by a housekeeping task that periodically gathers synthetic measurement data from a simulated sensing subsystem. Internally, this subsystem will rely on random number generation to produce representative values.</p> </li> <li> <p>Telecommand reception and acceptance: In an actual spacecraft, telecommands are sent from the ground segment to control the instrument\u2019s behavior. The on-board software receives these telecommands, validates them, and executes the corresponding actions. In our simplified scenario, telecommand reception will be simulated by user input from the standard input stream. The system will interpret each received character as a telecommand and respond with a corresponding telemetry acknowledgment message.</p> </li> </ul> <p>Together, these two components reproduce the structure of a complete on-board control application, combining periodic housekeeping with asynchronous telecommand handling.</p>"},{"location":"tutorial/#the-termina-execution-model","title":"The Termina Execution Model","text":"<p>Before starting the implementation, it is important to understand the software execution environment that supports Termina applications. The core component of the Termina development toolchain is its transpiler, which translates Termina source code into MISRA-compliant C code. The generated C code does not interact directly with the underlying real-time operating system (RTOS). Instead, it runs on top of the Termina Operating System Abstraction Layer (OSAL). The OSAL defines a uniform and well-specified application programming interface (API) that encapsulates the system services required by Termina applications, such as task scheduling, interrupt handling, synchronization, and inter-process communication. </p> <p>Each supported operating system implements its own version of the OSAL, adapting this interface to the primitives of the target RTOS. This design ensures that the transpiler's output is independent of the target platform, while maintaining the language's deterministic semantics and analyzable behavior.  </p> <p>In this tutorial, we will use the <code>posix-gcc</code> platform, a development and demonstration platform included with the Termina toolchain. It allows Termina applications to execute on conventional Unix-like systems such as Linux or macOS. The platform is intended primarily for prototyping and validation, rather than deployment on a real RTOS. Internally, the OSAL implementation for <code>posix-gcc</code> emulates real-time behavior using POSIX threads, timers, and synchronization primitives. While it does not provide hard real-time guarantees because execution depends on the host system's scheduler, it preserves the logical structure of a deterministic real-time system, enabling functional testing and behavioral analysis.</p> <p>The OSAL for this platform exposes a simple interface that emulates:</p> <ul> <li>an interrupt-like event triggered when there are characters available in the standard input stream buffer (<code>stdin</code>), and</li> <li>a telemetry output channel that sends messages to the standard output stream (<code>stdout</code>).</li> </ul> <p>These features allow us to simulate both telecommand reception and telemetry transmission:</p> <ul> <li>Telecommands will be represented by strings received through the standard input. Whenever characters are available to read, an input event is generated, triggering an interrupt handler that forwards the command to a task via a message queue.</li> <li>Telemetries will be represented by formatted text messages printed to the console by the housekeeping task, simulating the output of telemetry packets through a communication interface.</li> </ul> <p>This setup provides a complete, fully functional environment for testing Termina applications without requiring physical hardware or an embedded RTOS. It enables the reader to explore Termina's reactive execution model, memory safety guarantees, and modular structure through a practical, hands-on example.</p>"},{"location":"tutorial/#application-architecture-overview","title":"Application architecture overview","text":"<p>The architecture of the demo application we will be building in this introductory course is shown in Figure 1.</p> Figure 1. ICU Software Demo Architecture <p>The application defines two primary event emitters, which serve as the sources of activity within the system. The first emitter, called <code>hk_timer</code>, is a periodic timer that generates time-triggered events at regular intervals. This event emitter is connected to the <code>hk_task</code>. In Termina, a task is a reactive component that executes one or more actions in response to events or messages. Tasks may hold internal state variables and expose ports that connect them to other components, such as event sinks, message inputs, or access ports to shared resources. The <code>hk_task</code> specifically represents the instrument control software's housekeeping subsystem. With each event generated by the periodic timer, the task executes an action that emulates the process of collecting system data, aggregating it, and generating a telemetry message.</p> <p>In a real on-board system, system data is stored in a centralized repository known as the system data pool. This component manages all engineering and status parameters that describe the platform or instrument's current state. Typical housekeeping data includes parameters such as voltages, currents, temperatures, operating modes, and internal status flags. These parameters are continuously updated by different subsystems and made available to components that require access to the system state, such as telemetry generators and health-monitoring functions.</p> <p>In this application, the system data pool is represented as a resource called <code>system_data_pool</code>. Resources are passive components that encapsulate shared data and provide a set of procedures that tasks or handlers can invoke. Access to these resources is automatically synchronized by the runtime system when needed, ensuring mutual exclusion and preventing concurrent updates that could lead to inconsistent state information. This design effectively models the essential behavior of a real on-board data pool, which must guarantee consistency and determinism even when accessed by multiple concurrent processes.</p> <p>The <code>system_data_pool</code> resource in this application provides a procedure that returns a snapshot of the current system state. To model data collection from the system as it would occur in a real scenario, a second resource, <code>sensor_array</code>, has been defined. This resource emulates the behavior of a sensor system. The data obtained in this case is not from a real system but is instead generated synthetically using a random number generator integrated into the resource. Each time the housekeeping task requests new data, the data pool queries the <code>sensor_array</code> resource and returns simulated measurements that appear to be acquired from actual instrumentation. This abstraction allows the housekeeping logic to remain unchanged, regardless of whether the data originates from simulated or actual hardware.</p> <p>After retrieving the data, the housekeeping task uses an additional resource named <code>tm_channel</code> to emulate telemetry transmission. This resource implements a set of procedures corresponding to different types of telemetry messages. When one of these procedures is invoked, the resource formats the message and uses a system call to print it to the standard output stream. This mechanism simulates the behavior of a telemetry interface transmitting housekeeping packets to the spacecraft platform.</p> <p>The second emitter, called <code>kbd_irq</code>, represents an asynchronous interrupt source that generates an event whenever new data becomes available in the standard input buffer. This emitter is connected to a handler, which is a lightweight reactive component that executes a single action immediately in response to an event, typically an interrupt. Handlers are intended for short, time-critical operations that must react promptly to external stimuli and delegate longer computations to other system components.</p> <p>In this application, the handler is activated whenever the user enters a new character string on the console. The incoming character string represents a telecommand, which is a command received from the ground segment. The handler reads the character string using a system call and forwards it to another task named <code>manager</code> through a message queue called <code>tc_channel</code>. A message queue in Termina provides asynchronous communication between components. Queues are declared statically and have a bounded capacity.</p> <p>The <code>manager</code> task emulates the main control logic of the instrument control unit. It defines an action that is automatically executed whenever a new message is received on the <code>tc_channel</code> message queue. This action inspects the received telecommand and determines whether to accept or reject it. In either case, the task uses the <code>tm_channel</code> resource to generate an acknowledgment message, which is printed to standard output, emulating the transmission of an acceptance or rejection packet.</p> <p>Data transferred via the telecommand message queue is stored in dynamically allocated memory. Termina handles dynamic allocation deterministically via memory pools. A memory pool defines a fixed number of preallocated blocks that can be allocated and released at runtime without fragmentation or unpredictable latency. In this application, a pool named <code>tc_pool</code> manages the memory used to store incoming telecommands. When the handler receives a new command, it allocates a memory block from this pool and stores the input data in it. The block is then encapsulated in a message and sent to the manager task through the message queue. Once the task has processed the command, it releases the memory block back to the pool.</p>"},{"location":"tutorial/#creating-the-project","title":"Creating the project","text":"<p>Before implementing the application, we must create a new Termina project that will serve as the workspace for all source files and configuration elements. In the Termina toolchain, a project defines the complete structure of an application, including its source code, build configuration, and target deployment platform. Projects are initialized through the command-line interface of the Termina environment.</p> <p>To create a new project named <code>icusw_demo</code>, execute the following command from the terminal:</p> <pre><code>$ termina new icusw_demo\n</code></pre> <p>This command instructs the Termina toolchain to generate a new project skeleton with the standard directory layout and configuration files. Once the command has completed, a directory named <code>icusw_demo/</code> will be created with the following contents:</p> <pre><code>icusw_demo/\n\u251c\u2500\u2500 termina.yaml\n\u251c\u2500\u2500 app/\n\u2502   \u2514\u2500\u2500 app.fin\n\u251c\u2500\u2500 src/\n\u2514\u2500\u2500 output/\n</code></pre> <p>The file <code>termina.yaml</code> is the project's configuration file, where the project name, build options, and target platform will be specified. The app directory contains the main module <code>app.fin</code>, which defines the application's top-level structure and connects all components. The <code>src</code> directory is reserved for additional modules that may define types, such as task or resource classes, or support functions. Finally, the <code>output</code> directory will store the generated C code produced by the transpiler.</p>"},{"location":"tutorial/#telecommand-descriptors","title":"Telecommand descriptors","text":"<p>The first step in implementing the application is to define a structured type that represents the telecommands received by the system. We will create a structure named <code>TCDescriptor</code>, which will store the contents of each received telecommand and allow it to be transferred between components of the application, such as the input handler and the manager task.</p> <p>In Termina, structured types are defined using the <code>struct</code> keyword. A struct is a user-defined composite type that groups several related data fields. Each field has a name and a type, and all fields must be initialized before use. Structs provide a convenient way to represent complex data in a clear and strongly typed manner.</p> <p>We will declare this new type in a module called <code>types.fin</code>, located inside a new directory <code>src/common/</code>. This directory will hold elements shared across the application's modules.</p> <p>The structure will be defined as follows:</p> TerminaC <pre><code>struct TCDescriptor {\n    payload : [char; 256];\n    size : usize;\n};\n</code></pre> <pre><code>typedef struct {\n    char payload[256U];\n    size_t size;\n} TCDescriptor;\n</code></pre> <p>Note</p> <p>For some of the code blocks written in Termina throughout this tutorial, the corresponding C code generated by the transpiler is also provided in the reference material. These examples are intended to help you understand how Termina constructs are translated into deterministic, MISRA-compliant C code, and how the transpiler preserves the structure and semantics of the original program.</p> <p>The structure defines two fields. The <code>payload</code> field is a fixed-length array containing up to 256 elements of type <code>char</code>, which will store the characters of the telecommand received through the standard input. Arrays in Termina always have a size known at compile time and cannot grow dynamically. The <code>char</code> type represents a single character and is suitable for textual data. The second field, size, is of type <code>usize</code>, the unsigned integer type used to represent counts, sizes, and array indices. It will store the number of valid characters currently contained in the payload array.</p> <p>In our application, telecommands are simulated by entering strings through the standard input. When a telecommand is received, its contents will be copied into a TCDescriptor instance, and the size field will be updated to indicate how many characters were stored.</p>"},{"location":"tutorial/#telecommand-acceptance","title":"Telecommand acceptance","text":"<p>To determine whether a received telecommand is valid, we will implement a function named <code>accept_tc()</code>. In Termina, a function is a block of code that performs a computation and always terminates. Functions may take parameters and return values, but they cannot access global data directly. This restriction ensures that all information used by a function is passed explicitly, improving analyzability and preventing hidden side effects. Functions can receive parameters either by value or by reference, depending on whether the called code needs to modify the input data.</p> <p>In our case, the <code>accept_tc()</code> function will receive an immutable reference to a <code>TCDescriptor</code> object, meaning that the function can read the contents of the telecommand but cannot modify them. The function will return a value of type <code>Status&lt;u32&gt;</code>, one of Termina\u2019s built-in monadic result types used to represent the outcome of an operation that may succeed or fail. The type argument <code>u32</code> indicates that the error information carried by a Failure value will be represented as an unsigned 32-bit integer. A value of <code>Success</code> signals that the telecommand was accepted, while <code>Failure(E)</code> indicates an error with code <code>E</code> of type <code>u32</code>.</p> <p>The acceptance rule is simple: a telecommand is valid if the text it contains begins with the letter <code>v</code>. If the first character is <code>e</code>, the telecommand is considered incorrect and associated with error type <code>0</code>. Any other initial character results in error type <code>1</code>.</p> <p>We will implement the function in a new module named <code>accept.fin</code>, located in the directory <code>src/lib/</code>. The file must begin by importing the <code>common.types</code> module, which contains the definition of the <code>TCDescriptor</code> structure.</p> TerminaC <pre><code>import common.types;\n\nfunction accept_tc(tc : &amp;TCDescriptor) -&gt; Status&lt;u32&gt; {\n\n    var status : Status&lt;u32&gt; = Success;\n\n    if tc-&gt;payload[0] == 'e' {\n        status = Failure(0);\n    } else if tc-&gt;payload[0] != 'v' {\n        status = Failure(1);\n    } else {\n\n    }\n\n    return status;\n\n}\n</code></pre> <pre><code>#include \"lib/accept.h\"\n\n__status_uint32_t accept_tc(const TCDescriptor * const tc) {\n\n    __status_uint32_t status;\n    status.__variant = Success;\n\n    if (tc-&gt;payload[0U] == 'e') {\n\n        status.__variant = Failure;\n        status.Failure.__0 = 0U;\n\n    } else if (tc-&gt;payload[0U] != 'v') {\n\n        status.__variant = Failure;\n        status.Failure.__0 = 1U;\n\n    } else {\n\n\n    }\n\n    return status;\n\n}\n</code></pre> <p>The function evaluates the first letter of the <code>payload</code> field of the structure passed by reference and, depending on its value, update the local variable <code>status</code> accordingly.</p>"},{"location":"tutorial/#emulating-a-sensor-array","title":"Emulating a sensor array","text":"<p>To simulate the behavior of a sensing subsystem, we will implement a resource that emulates the operation of a sensor array. In Termina, a resource is a passive component that encapsulates shared functionality and provides access to one or more interfaces consisting of procedures. Procedures represent operations that can be called by tasks or handlers, and access to resources is always mutually exclusive, ensuring deterministic and thread-safe interactions.</p> <p>In a real on-board system, a sensor array would be responsible for acquiring measurements such as voltages, currents, or temperatures from different hardware sensors. In our demonstration, however, the resource will generate synthetic readings using a pseudo-random number generator. Each generated number will represent the value that might have been read from a sensor channel.</p> <p>Before defining the resource itself, we must declare the interface it provides, specifying the list of available procedures. We will then define the corresponding resource class, which contains the actual implementation of these procedures.</p> <p>Both the interface and the resource class will be defined in a new module located at <code>src/resources/sensor_array.fin</code>. The contents of the file are as follows:</p> TerminaCC (header) <pre><code>constexpr SENSOR_ARRAY_SIZE : usize = 10;\n\ninterface ISensorArray {\n\n    procedure get_sensor_value(&amp;mut self, index: usize,\n                               value : &amp;mut Option&lt;u32&gt;);\n\n};\n\nresource class CEmuSensorArray provides ISensorArray {\n\n    seed : u32;\n\n    method get_random_u32(&amp;mut self) -&gt; u32 {\n\n        var next : u32 = self-&gt; seed;\n        var rnd : u32 = 0;\n\n        next = next * 1103515245 : u32;\n        next = next + 12345 : u32;\n        rnd = (next / 65536 : u32) % 2048 : u32;\n\n        next = next * 1103515245 : u32;\n        next = next + 12345 : u32;\n        rnd = rnd &lt;&lt; 10 : u32;\n        rnd = rnd ^(next / 65536 : u32) % 1024 : u32;\n\n        next = next * 1103515245 : u32;\n        next = next + 12345 : u32;\n        rnd = rnd &lt;&lt; 10 : u32;\n        rnd = rnd ^ (next / 65536 : u32) % 1024 : u32;\n\n        self-&gt;seed = next;\n\n        return rnd;\n\n    }\n\n    procedure get_sensor_value(&amp;mut self, index : usize, \n                               value : &amp;mut Option&lt;u32&gt;) {\n\n        *value = None;\n\n        if index &gt;= 0 &amp;&amp; index &lt; SENSOR_ARRAY_SIZE {\n            *value = Some(self-&gt;get_random_u32());\n        }\n\n        return;\n\n    }\n\n};\n</code></pre> <pre><code>#include \"resources/sensor_array.h\"\n\nuint32_t CEmuSensorArray__get_random_u32(const __termina_event_t * const __ev,\n                                         CEmuSensorArray * const self) {\n\n    uint32_t next = self-&gt;seed;\n\n    uint32_t rnd = 0U;\n\n    next = next * 1103515245U;\n\n    next = next + 12345U;\n\n    rnd = (uint32_t)(next / 65536U) % 2048U;\n\n    next = next * 1103515245U;\n\n    next = next + 12345U;\n\n    rnd = rnd &lt;&lt; 10U;\n\n    rnd = rnd ^ (uint32_t)((uint32_t)(next / 65536U) % 1024U);\n\n    next = next * 1103515245U;\n\n    next = next + 12345U;\n\n    rnd = rnd &lt;&lt; 10U;\n\n    rnd = rnd ^ (uint32_t)((uint32_t)(next / 65536U) % 1024U);\n\n    self-&gt;seed = next;\n\n    return rnd;\n\n}\n\nvoid CEmuSensorArray__get_sensor_value(const __termina_event_t * const __ev,\n                                       void * const __this, size_t index,\n                                       __option_uint32_t * const value) {\n\n    CEmuSensorArray * self = (CEmuSensorArray *)__this;\n\n    __termina_lock_t __lock = __termina_resource__lock(&amp;__ev-&gt;owner,\n                                                    &amp;self-&gt;__lock_type);\n\n    (*value).__variant = None;\n\n    if (index &gt;= 0U &amp;&amp; index &lt; 10U) {\n\n        (*value).__variant = Some;\n        (*value).Some.__0 = CEmuSensorArray__get_random_u32(__ev, self);\n\n    }\n\n    __termina_resource__unlock(&amp;__ev-&gt;owner, &amp;self-&gt;__lock_type, __lock);\n\n    return;\n\n}\n</code></pre> <pre><code>typedef struct {\n    __termina_resource_lock_type_t __lock_type;\n    uint32_t seed;\n} CEmuSensorArray;\n\nuint32_t CEmuSensorArray__get_random_u32(const __termina_event_t * const __ev,\n                                         CEmuSensorArray * const self);\n\nvoid CEmuSensorArray__get_sensor_value(const __termina_event_t * const __ev,\n                                       void * const __this, size_t index,\n                                       __option_uint32_t * const value);\n</code></pre> <p>The module begins by declaring a constant expression, <code>SENSOR_ARRAY_SIZE</code>, which defines the number of simulated sensors in the array. The interface <code>ISensorArray</code> declares a single procedure, <code>get_sensor_value()</code>, which takes two arguments. The first argument, index, indicates which sensor\u2019s value to retrieve, with valid indices ranging from 0 to <code>SENSOR_ARRAY_SIZE</code> - 1. The second argument is a mutable reference to an object of type <code>Option&lt;u32&gt;</code>, where the sensor value will be stored if the index is valid.</p> <p>The resource class <code>CEmuSensorArray</code> implements the <code>ISensorArray</code> interface. It defines a field named <code>seed</code>, which stores the internal state of the pseudo-random number generator. The class includes a private method, <code>get_random_u32()</code>, which uses a deterministic arithmetic algorithm to generate pseudo-random 32-bit integers. This sequence mimics random sensor readings while ensuring reproducibility across executions.</p> <p>The <code>get_sensor_value()</code> procedure uses the provided index to determine whether a valid sensor exists. If the index falls within the valid range, the procedure writes a generated value into the variable referenced by value using the enumeration type <code>Option&lt;u32&gt;</code>. This type allows the procedure to indicate whether a valid result was produced (<code>Some(value)</code>) or not (<code>None</code>), enforcing explicit handling of possible absence of data by the caller.</p> <p>Once the resource class has been defined, we can instantiate the resource itself in the main application file <code>app/app.fin</code>. The instantiation associates the resource with a concrete name (<code>emu_sensor_array</code>) and initializes its internal fields. At the end of the file, add the following code:</p> Termina <pre><code>import resources.sensor_array;\n\nresource emu_sensor_array : CEmuSensorArray = {\n    seed = 0\n};\n</code></pre> <p>When defining a resource instance, each member field of the corresponding resource class must be given an initial value. In this case, the <code>seed</code> field is initialized to 0, providing a known starting point for the random number generator.</p>"},{"location":"tutorial/#defining-the-system-data-pool","title":"Defining the system data pool","text":"<p>The next step will be to define the resource that will implement the system data pool functionality. The system data pool resource models a central repository of housekeeping parameters that represent the current operational state of the system. In spacecraft and other embedded control applications, a system data pool serves as a shared data structure that stores engineering parameters such as voltages, currents, temperatures, or mode indicators. These parameters can be read by telemetry functions to report the system state or updated by control tasks when new measurements or status changes occur. Modeling this concept as a Termina resource provides deterministic access and guarantees mutual exclusion when multiple components interact with the shared data.</p> <p>We will define both the interface and the resource class in a new file called <code>src/resources/sys_data_pool.fin</code>. The initial content of the file is as follows:</p> TerminaCC (header) <pre><code>constexpr SDP_NUM_PARAMS : usize = 10;\n\ninterface ISystemDataPool {\n\n    procedure get_param(&amp;mut self, idx : usize, value : &amp;mut Option&lt;u32&gt;);\n    procedure set_param(&amp;mut self, idx : usize, value : u32);\n\n};\n\nresource class CSystemDataPool provides ISystemDataPool {\n\n    param_values : [u32; SDP_NUM_PARAMS];\n\n    procedure get_param(&amp;mut self, idx : usize, value : &amp;mut Option&lt;u32&gt;) {\n\n        *value = None;\n\n        if idx &lt; SDP_NUM_PARAMS {\n            *value = Some(self-&gt;param_values[idx]);\n        } \n\n        return;\n\n    }\n\n    procedure set_param(&amp;mut self, idx : usize, value : u32) {\n\n        if idx &lt; SDP_NUM_PARAMS {\n            self-&gt;param_values[idx] = value;\n        }\n\n        return;\n\n    }\n\n};\n</code></pre> <pre><code>#include \"resources/sys_data_pool.h\"\n\nvoid CSystemDataPool__get_param(const __termina_event_t * const __ev,\n                                void * const __this, size_t idx,\n                                __option_uint32_t * const value) {\n\n    CSystemDataPool * self = (CSystemDataPool *)__this;\n\n    __termina_lock_t __lock = __termina_resource__lock(&amp;__ev-&gt;owner,\n                                                    &amp;self-&gt;__lock_type);\n\n    (*value).__variant = None;\n\n    if (idx &lt; 10U) {\n\n        (*value).__variant = Some;\n        (*value).Some.__0 = self-&gt;param_values[__termina_array__index(10U,\n                                                                      idx)];\n\n    }\n\n    __termina_resource__unlock(&amp;__ev-&gt;owner, &amp;self-&gt;__lock_type, __lock);\n\n    return;\n\n}\n\nvoid CSystemDataPool__set_param(const __termina_event_t * const __ev,\n                                void * const __this, size_t idx,\n                                uint32_t value) {\n\n    CSystemDataPool * self = (CSystemDataPool *)__this;\n\n    __termina_lock_t __lock = __termina_resource__lock(&amp;__ev-&gt;owner,\n                                                    &amp;self-&gt;__lock_type);\n\n    if (idx &lt; 10U) {\n\n        self-&gt;param_values[__termina_array__index(10U, idx)] = value;\n\n    }\n\n    __termina_resource__unlock(&amp;__ev-&gt;owner, &amp;self-&gt;__lock_type, __lock);\n\n    return;\n\n}\n</code></pre> <pre><code>typedef struct {\n    __termina_resource_lock_type_t __lock_type;\n    uint32_t param_values[10U];\n} CSystemDataPool;\n\nvoid CSystemDataPool__get_param(const __termina_event_t * const __ev,\n                                void * const __this, size_t idx,\n                                __option_uint32_t * const value);\n\nvoid CSystemDataPool__set_param(const __termina_event_t * const __ev,\n                                void * const __this, size_t idx,\n                                uint32_t value);\n</code></pre> <p>The code begins by defining a constant expression, <code>SDP_NUM_PARAMS</code>, which specifies the number of parameters stored in the pool. This value determines the fixed size of the array used to hold system data.</p> <p>The interface <code>ISystemDataPool</code> defines the contract that any implementing class must follow. It declares two procedures: <code>get_param()</code>, which retrieves the value of a parameter given its index, and <code>set_param()</code>, which updates the value of a parameter.</p> <p>Both procedures take an index of type usize that identifies the parameter to be accessed. In <code>get_param()</code>, the second argument is a mutable reference to an object of type <code>Option&lt;u32&gt;</code>. The use of an <code>Option</code> type ensures that the caller must explicitly handle the case where the requested parameter index is invalid. When the index is within bounds, the procedure assigns <code>Some(value)</code>; otherwise, it leaves the result as <code>None</code>.</p> <p>The resource class <code>CSystemDataPool</code> implements the <code>ISystemDataPool</code> interface and provides the concrete behavior of the data pool. It defines an internal array <code>param_values</code>, which contains <code>SDP_NUM_PARAMS</code> unsigned 32-bit integers. This array represents the current values of all system parameters. </p> <p>The <code>set_param()</code> procedure updates the specified parameter value if the index is valid, while <code>get_param()</code> returns the stored value through the reference provided by the caller. Out-of-bounds indices are ignored gracefully, preventing any illegal memory access.</p> <p>Once the <code>CSystemDataPool</code> class has been implemented, we will need to instantiate the <code>sys_data_pool</code> resource. To do this, we will need to edit the <code>app/app.fin</code> file. First, we need to add the appropriate import at the beginning of the file:</p> Termina <pre><code>import resources.sys_data_pool;\n</code></pre> <p>And then, we need to append the following code to the end of the file:</p> Termina <pre><code>resource sys_data_pool : CSystemDataPool = {\n    param_values = [0; SDP_NUM_PARAMS]\n};\n</code></pre>"},{"location":"tutorial/#the-telemetry-channel","title":"The telemetry channel","text":"<p>The telemetry channel resource models the mechanism through which the application transmits housekeeping and diagnostic data to an external system. In actual on-board software, the telemetry subsystem is responsible for formatting and sending packets that report the spacecraft or instrument\u2019s internal state. These packets are typically identified by a Service Type and Service Subtype in compliance with the Packet Utilization Standard (PUS), a widely adopted standard in the space domain.</p> <p>In this simplified application, telemetry transmission is emulated by writing formatted text messages to the system console. This allows us to validate the application\u2019s behavior without requiring dedicated hardware communication interfaces.</p> <p>The implementation of the telemetry resource will be done in a new module named <code>src/resources/tm_channel.fin</code>. The contents of the file will be as follows:</p> TerminaCC (header) <pre><code>import common.types;\n\ninterface TMChannelInterface {\n\n    procedure send_tm_3_25(&amp;mut self, hk_data_size : const usize, hk_data : &amp;[u32; hk_data_size]);\n    procedure send_tm_1_1(&amp;mut self);\n    procedure send_tm_1_2(&amp;mut self, value : u32);\n\n};\n\nresource class TMChannel provides TMChannelInterface {\n\n    system_port : access SystemAPI;\n\n    procedure send_tm_3_25(&amp;mut self, hk_data_size : const usize, hk_data : &amp;[u32; hk_data_size]) {\n\n        // Handle TM_2_25 telemetry\n        let msg : [char; 15] = \"Send TM(3,25): \";\n        let base : SysPrintBase = SysPrintBase::Decimal;\n        let comma : [char; 2] = \", \";\n\n        self-&gt;system_port.print(15, &amp;msg);\n\n        for i : usize in 0 .. (hk_data_size - 1) {\n            self-&gt;system_port.print_u32(hk_data[i], base);\n            self-&gt;system_port.print(2, &amp;comma);\n        }\n        self-&gt;system_port.println_u32(hk_data[hk_data_size - 1], base);\n\n        return;\n\n    }\n\n    procedure send_tm_1_1(&amp;mut self) {\n\n        let msg : [char; 12] = \"Send TM(1,1)\";\n        self-&gt;system_port.println(12, &amp;msg);\n\n        return;\n\n    }\n\n    procedure send_tm_1_2(&amp;mut self, value : u32) {\n\n        let msg : [char; 27] = \"Send TM(1,2) - Error code: \";\n        self-&gt;system_port.print(27, &amp;msg);\n        let base : SysPrintBase = SysPrintBase::Decimal;\n        self-&gt;system_port.println_u32(value, base);\n\n        return;\n\n    }\n\n};\n</code></pre> <pre><code>#include \"resources/tm_channel.h\"\n\nvoid TMChannel__send_tm_1_1(const __termina_event_t * const __ev,\n                            void * const __this) {\n\n    TMChannel * self = (TMChannel *)__this;\n\n    __termina_lock_t __lock = __termina_resource__lock(&amp;__ev-&gt;owner,\n                                                    &amp;self-&gt;__lock_type);\n\n    char msg[12U];\n    msg[0U] = 'S';\n    msg[1U] = 'e';\n    msg[2U] = 'n';\n    msg[3U] = 'd';\n    msg[4U] = ' ';\n    msg[5U] = 'T';\n    msg[6U] = 'M';\n    msg[7U] = '(';\n    msg[8U] = '1';\n    msg[9U] = ',';\n    msg[10U] = '1';\n    msg[11U] = ')';\n\n    self-&gt;system_port.println(__ev, 12U, msg);\n\n    __termina_resource__unlock(&amp;__ev-&gt;owner, &amp;self-&gt;__lock_type, __lock);\n\n    return;\n\n}\n\nvoid TMChannel__send_tm_1_2(const __termina_event_t * const __ev,\n                            void * const __this, uint32_t value) {\n\n    TMChannel * self = (TMChannel *)__this;\n\n    __termina_lock_t __lock = __termina_resource__lock(&amp;__ev-&gt;owner,\n                                                    &amp;self-&gt;__lock_type);\n\n    char msg[27U];\n    msg[0U] = 'S';\n    msg[1U] = 'e';\n    msg[2U] = 'n';\n    msg[3U] = 'd';\n    msg[4U] = ' ';\n    msg[5U] = 'T';\n    msg[6U] = 'M';\n    msg[7U] = '(';\n    msg[8U] = '1';\n    msg[9U] = ',';\n    msg[10U] = '2';\n    msg[11U] = ')';\n    msg[12U] = ' ';\n    msg[13U] = '-';\n    msg[14U] = ' ';\n    msg[15U] = 'E';\n    msg[16U] = 'r';\n    msg[17U] = 'r';\n    msg[18U] = 'o';\n    msg[19U] = 'r';\n    msg[20U] = ' ';\n    msg[21U] = 'c';\n    msg[22U] = 'o';\n    msg[23U] = 'd';\n    msg[24U] = 'e';\n    msg[25U] = ':';\n    msg[26U] = ' ';\n\n    self-&gt;system_port.print(__ev, 27U, msg);\n\n    SysPrintBase base;\n    base.__variant = SysPrintBase__Decimal;\n\n    self-&gt;system_port.println_u32(__ev, value, base);\n\n    __termina_resource__unlock(&amp;__ev-&gt;owner, &amp;self-&gt;__lock_type, __lock);\n\n    return;\n\n}\n\nvoid TMChannel__send_tm_3_25(const __termina_event_t * const __ev,\n                            void * const __this, const size_t hk_data_size,\n                            const uint32_t hk_data[hk_data_size]) {\n\n    TMChannel * self = (TMChannel *)__this;\n\n    __termina_lock_t __lock = __termina_resource__lock(&amp;__ev-&gt;owner,\n                                                    &amp;self-&gt;__lock_type);\n\n    char msg[15U];\n    msg[0U] = 'S';\n    msg[1U] = 'e';\n    msg[2U] = 'n';\n    msg[3U] = 'd';\n    msg[4U] = ' ';\n    msg[5U] = 'T';\n    msg[6U] = 'M';\n    msg[7U] = '(';\n    msg[8U] = '3';\n    msg[9U] = ',';\n    msg[10U] = '2';\n    msg[11U] = '5';\n    msg[12U] = ')';\n    msg[13U] = ':';\n    msg[14U] = ' ';\n\n    SysPrintBase base;\n    base.__variant = SysPrintBase__Decimal;\n\n    char comma[2U];\n    comma[0U] = ',';\n    comma[1U] = ' ';\n\n    self-&gt;system_port.print(__ev, 15U, msg);\n\n    for (size_t i = 0U; i &lt; hk_data_size - 1U; i = i + 1U) {\n\n        self-&gt;system_port.print_u32(__ev,\n                                    hk_data[__termina_array__index(hk_data_size,\n                                                                i)], base);\n\n        self-&gt;system_port.print(__ev, 2U, comma);\n\n    }\n\n    self-&gt;system_port.println_u32(__ev, hk_data[hk_data_size - 1U], base);\n\n    __termina_resource__unlock(&amp;__ev-&gt;owner, &amp;self-&gt;__lock_type, __lock);\n\n    return;\n\n}\n</code></pre> <pre><code>typedef struct {\n    __termina_resource_lock_type_t __lock_type;\n    struct {\n        void (* print)(const __termina_event_t * const, const size_t,\n                       const char *);\n        void (* print_u32)(const __termina_event_t * const, uint32_t,\n                           SysPrintBase);\n        void (* println)(const __termina_event_t * const, const size_t,\n                         const char *);\n        void (* println_u32)(const __termina_event_t * const, uint32_t,\n                             SysPrintBase);\n    } system_port;\n} TMChannel;\n\nvoid TMChannel__send_tm_1_1(const __termina_event_t * const __ev,\n                            void * const __this);\n\nvoid TMChannel__send_tm_1_2(const __termina_event_t * const __ev,\n                            void * const __this, uint32_t value);\n\nvoid TMChannel__send_tm_3_25(const __termina_event_t * const __ev,\n                            void * const __this, const size_t hk_data_size,\n                            const uint32_t hk_data[hk_data_size]);\n</code></pre> <p>The module defines the interface <code>TMChannelInterface</code>, which specifies three procedures corresponding to the different telemetry messages that the system can send:</p> <ul> <li><code>send_tm_3_25()</code>: simulates the transmission of housekeeping telemetry packets. It receives two arguments: the size of the housekeeping dataset and a reference to the array that stores the parameter values. In this case, the parameter <code>hk_data_size</code> is declared as a constant parameter (<code>const usize</code>), meaning that its value must be known at compile time. Termina allows developers to use this type of argument to, among other uses, parameterize the size of arrays used as input parameters.</li> <li><code>send_tm_1_1()</code>: represents a telecommand acceptance report, sent when a received telecommand is successfully validated.</li> <li><code>send_tm_1_2()</code>: represents a telecommand rejection report, which includes an error code provided as a 32-bit unsigned integer argument.</li> </ul> <p>The resource class <code>TMChannel</code> implements this interface. It declares a single field, <code>system_port</code>, which is an access port to the <code>SystemAPI</code> interface provided by the underlying platform. Through this port, the resource can use low-level system procedures for input/output operations, such as printing strings or numbers to the console.</p> <p>Each procedure uses these system calls to emulate the generation of telemetry packets. For example, <code>send_tm_3_25()</code> prints the label <code>Send TM(3,25):</code> followed by the list of housekeeping parameter values separated by commas. Similarly, <code>send_tm_1_1()</code> prints a short acknowledgment message, while <code>send_tm_1_2()</code> outputs an error message followed by the corresponding numerical error code.</p> <p>By abstracting telemetry transmission as a resource, the system maintains a clear separation between data generation and communication mechanisms. In a real deployment, the same interface could be implemented using an actual communication driver instead of the console-based emulation.</p> <p>To enable the use of system calls within Termina applications, the runtime must provide an internal resource named <code>system_entry</code>. This special resource acts as the gateway between Termina code and the underlying platform services implemented by the Operating System Abstraction Layer (OSAL). It provides access to low-level functions such as console input/output, timing services, and other system-dependent primitives used by higher-level components like the telemetry channel.</p> <p>The <code>system_entry</code> resource is not instantiated by default. Its deployment is controlled by a global configuration parameter in the project\u2019s <code>termina.yaml</code> file. To enable it, the following line must be added to the configuration file located at the root of the project:</p> YAML <pre><code>enable-system-port : true\n</code></pre> <p>When this option is set, the Termina runtime automatically instantiates and exposes the system_entry resource during system initialization. Once this feature has been enabled, the telemetry channel resource (<code>tm_channel</code>) can be deployed and connected to the system interface.</p> <p>To do this, first import the telemetry channel module in the main application file <code>app/app.fin</code>:</p> Termina <pre><code>import resources.tm_channel;\n</code></pre> <p>And then instantiate the resource and connect it to the runtime-provided system entry point by adding the following code at the end of the same file:</p> Termina <pre><code>resource tm_channel : TMChannel = {\n    system &lt;-&gt; system_entry\n};\n</code></pre> <p>This declaration creates an instance of the <code>tm_channel</code> resource and links its <code>system_port</code> access port to the <code>system_entry</code> resource. Through this connection, the telemetry channel gains access to the OSAL\u2019s input/output facilities, enabling it to emulate telemetry transmission by printing formatted messages to the console.</p>"},{"location":"tutorial/#doing-the-housekeeping","title":"Doing the housekeeping","text":"<p>The housekeeping function is one of the core elements of any on-board control application. Its purpose is to periodically collect engineering and diagnostic parameters from the system, store them in a structured form, and transmit them as telemetry packets. This function ensures continuous monitoring of the instrument\u2019s operational status and provides the data necessary for health assessment and maintenance.</p> <p>In our application, the housekeeping function is divided into two complementary components:</p> <ul> <li>the housekeeping subsystem, a passive resource, which encapsulates the logic for data acquisition and telemetry generation, and</li> <li>the housekeeping task, which invokes the resource at regular intervals according to a periodic schedule.</li> </ul>"},{"location":"tutorial/#the-housekeeping-subsystem","title":"The housekeeping subsystem","text":"<p>The housekeeping subsystem is modeled as a passive resource that encapsulates the logic required to collect and publish housekeeping data. The procedures provided by this resource will be called by a specialized housekeeping task to update parameters and generate telemetry at regular intervals.</p> <p>The housekeeping subsystem coordinates three main components: the sensor array, which provides synthetic sensor readings; the system data pool, which stores and manages the current system parameters; and the telemetry channel, which transmits housekeeping reports.</p> <p>The implementation of the resource will be done in a new module called <code>src/resources/hk_subsystem.fin</code>. The contents of the file will be as follows:</p> TerminaCC (header) <pre><code>import resources.tm_channel;\nimport resources.sensor_array;\nimport resources.sys_data_pool;\n\ninterface IHKSubsystem {\n\n    procedure update_params(&amp;mut self);\n    procedure do_housekeeping(&amp;mut self);\n\n};\n\nresource class CHKSubsystem provides IHKSubsystem {\n\n    interval : u32;\n    interval_control : u32;\n\n    sys_data_pool_port : access ISystemDataPool;\n    sensor_array_port : access ISensorArray;\n    tm_channel_port : access TMChannelInterface;\n\n    procedure update_params(&amp;mut self) {\n\n        var opt_value : Option&lt;u32&gt; = None;\n\n        for i : usize in 0 .. SENSOR_ARRAY_SIZE {\n\n            self-&gt;sensor_array_port.get_sensor_value(i, &amp;mut opt_value);\n\n            match opt_value {\n\n                case Some(v) =&gt; {\n                    self-&gt;sys_data_pool_port.set_param(i, v);\n                }\n\n                case None =&gt; {\n\n                }\n\n            }\n        }\n\n        return;\n\n    }\n\n    procedure do_housekeeping(&amp;mut self) {\n\n        self-&gt;interval_control = self-&gt;interval_control + 1;\n\n        if self-&gt;interval_control == self-&gt;interval {\n\n            self-&gt;interval_control = 0;\n\n            var hk_data : [u32; SDP_NUM_PARAMS] = [0; SDP_NUM_PARAMS];\n            var opt_value : Option&lt;u32&gt; = None;\n\n            for i : usize in 0 .. SDP_NUM_PARAMS {\n\n                self-&gt;sys_data_pool_port.get_param(i, &amp;mut opt_value);\n\n                match opt_value {\n\n                    case Some(v) =&gt; {\n                        hk_data[i] = v;\n                    }\n\n                    case None =&gt; {\n\n                    }\n\n                }\n            }            \n\n            self-&gt;tm_channel_port.send_tm_3_25(SENSOR_ARRAY_SIZE, &amp;hk_data);\n\n        }\n\n        return;\n\n    }\n\n};\n</code></pre> <pre><code>#include \"resources/hk_subsystem.h\"\n\nvoid CHKSubsystem__do_housekeeping(const __termina_event_t * const __ev,\n                                void * const __this) {\n\n    CHKSubsystem * self = (CHKSubsystem *)__this;\n\n    __termina_lock_t __lock = __termina_resource__lock(&amp;__ev-&gt;owner,\n                                                    &amp;self-&gt;__lock_type);\n\n    self-&gt;interval_control = self-&gt;interval_control + 1U;\n\n    if (self-&gt;interval_control == self-&gt;interval) {\n\n        self-&gt;interval_control = 0U;\n\n        uint32_t hk_data[10U];\n        for (size_t __i0 = 0U; __i0 &lt; 10U; __i0 = __i0 + 1U) {\n            hk_data[__i0] = 0U;\n        }\n\n        __option_uint32_t opt_value;\n        opt_value.__variant = None;\n\n        for (size_t i = 0U; i &lt; 10U; i = i + 1U) {\n\n            self-&gt;sys_data_pool_port.get_param(__ev,\n                                            self-&gt;sys_data_pool_port.__that,\n                                            i, &amp;opt_value);\n\n            if (opt_value.__variant == Some) {\n\n                uint32_t v = opt_value.Some.__0;\n\n                hk_data[__termina_array__index(10U, i)] = v;\n\n            } else {\n\n\n            }\n\n        }\n\n        self-&gt;tm_channel_port.send_tm_3_25(__ev, self-&gt;tm_channel_port.__that,\n                                        10U, hk_data);\n\n    }\n\n    __termina_resource__unlock(&amp;__ev-&gt;owner, &amp;self-&gt;__lock_type, __lock);\n\n    return;\n\n}\n\nvoid CHKSubsystem__update_params(const __termina_event_t * const __ev,\n                                void * const __this) {\n\n    CHKSubsystem * self = (CHKSubsystem *)__this;\n\n    __termina_lock_t __lock = __termina_resource__lock(&amp;__ev-&gt;owner,\n                                                    &amp;self-&gt;__lock_type);\n\n    __option_uint32_t opt_value;\n    opt_value.__variant = None;\n\n    for (size_t i = 0U; i &lt; 10U; i = i + 1U) {\n\n        self-&gt;sensor_array_port.get_sensor_value(__ev,\n                                                self-&gt;sensor_array_port.__that,\n                                                i, &amp;opt_value);\n\n        if (opt_value.__variant == Some) {\n\n            uint32_t v = opt_value.Some.__0;\n\n            self-&gt;sys_data_pool_port.set_param(__ev,\n                                            self-&gt;sys_data_pool_port.__that,\n                                            i, v);\n\n        } else {\n\n\n        }\n\n    }\n\n    __termina_resource__unlock(&amp;__ev-&gt;owner, &amp;self-&gt;__lock_type, __lock);\n\n    return;\n\n}\n</code></pre> <pre><code>typedef struct {\n    __termina_resource_lock_type_t __lock_type;\n    struct {\n        void * __that;\n        void (* send_tm_3_25)(const __termina_event_t * const, void * const,\n                            const size_t, const uint32_t *);\n    } tm_channel_port;\n    struct {\n        void * __that;\n        void (* get_sensor_value)(const __termina_event_t * const, void * const,\n                                size_t, __option_uint32_t * const);\n    } sensor_array_port;\n    struct {\n        void * __that;\n        void (* get_param)(const __termina_event_t * const, void * const,\n                        size_t, __option_uint32_t * const);\n        void (* set_param)(const __termina_event_t * const, void * const,\n                        size_t, uint32_t);\n    } sys_data_pool_port;\n    uint32_t interval_control;\n    uint32_t interval;\n} CHKSubsystem;\n\nvoid CHKSubsystem__do_housekeeping(const __termina_event_t * const __ev,\n                                   void * const __this);\n\nvoid CHKSubsystem__update_params(const __termina_event_t * const __ev,\n                                 void * const __this);\n</code></pre> <p>The interface <code>IHKSubsystem</code> defines two procedures. The first, <code>update_params()</code>, is responsible for refreshing the system data pool with the most recent readings from the sensor array. The second, <code>do_housekeeping()</code>, implements the periodic housekeeping logic that aggregates the data and sends a telemetry report when the defined interval is reached.</p> <p>The resource class <code>CHKSubsystem</code> provides this interface and maintains the necessary state for interval management. The fields <code>interval</code> and <code>interval_control</code> determine the execution cadence of the housekeeping operation: the active task that owns this subsystem will call <code>do_housekeeping()</code> periodically, and the procedure itself will decide when it is time to emit telemetry based on these counters.</p> <p>The access ports <code>sys_data_pool_port</code>, <code>sensor_array_port</code>, and <code>tm_channel_port</code> connect the subsystem to the system data pool, sensor array, and telemetry channel resources, respectively. All interactions with other components occur through these interfaces.</p> <p>The <code>update_params()</code> procedure iterates over all simulated sensors, requesting each reading from the sensor array and updating the corresponding entry in the system data pool. The use of the <code>Option&lt;u32&gt;</code> type forces explicit handling of the case where a sensor value may not be available.</p> <p>The <code>do_housekeeping()</code> procedure increments the control counter and, once the configured interval is reached, resets the counter and performs a complete data acquisition cycle. It retrieves all parameters from the system data pool, stores them in a fixed-size local array <code>hk_data</code>, and sends them to the telemetry channel using the <code>send_tm_3_25()</code> procedure. Both the number of parameters and the size of the array are known at compile time, which guarantees bounded execution and predictable memory usage.</p> <p>This design clearly separates the active scheduling logic, implemented by the task that periodically calls the housekeeping subsystem, from the passive data management logic encapsulated in the resource.</p> <p>Once the resource class has been defined, an instance of the housekeeping subsystem must be created in the main application file <code>app/app.fin</code>. At the beginning of the file, we must import the module:</p> Termina <pre><code>import resources.hk_subsystem;\n</code></pre> <p>And then add the following lines at the end of the same file:</p> Termina <pre><code>resource hk_subsystem : CHKSubsystem = {\n    interval = 5,\n    interval_control = 0,\n    sys_data_pool_port &lt;-&gt; sys_data_pool,\n    tm_channel_port &lt;-&gt; tm_channel,\n    sensor_array_port &lt;-&gt; emu_sensor_array\n};\n</code></pre> <p>This declaration instantiates the <code>hk_subsystem</code> resource with an update interval of five cycles and connects its access ports to the corresponding system components. The subsystem retrieves data from the <code>emu_sensor_array</code>, stores the values in the <code>sys_data_pool</code>, and sends telemetry through the <code>tm_channel</code>. The initialization of <code>interval_control</code> to zero ensures that the first telemetry packet will be generated after the configured number of cycles.</p>"},{"location":"tutorial/#the-housekeeping-task","title":"The housekeeping task","text":"<p>The housekeeping task is the active component responsible for executing the housekeeping subsystem at regular time intervals. In Termina, a task is an active entity that reacts to events or incoming messages by executing actions. Each action runs to completion without preemption, ensuring deterministic and analyzable behavior. Tasks typically interact with other system components through ports. For example, access ports to shared resources or event sinks that receive activation signals.</p> <p>The housekeeping task encapsulates the logic that periodically triggers the housekeeping subsystem resource. It does not perform data collection or telemetry generation directly; instead, it calls the procedures provided by the passive <code>CHKSubsystem</code> resource. This separation reflects a common pattern in on-board software design: tasks handle scheduling and event reactions, while resources encapsulate functionality and shared data.</p> <p>The task will be defined in the file <code>tasks/housekeeping.fin</code>:</p> Termina <pre><code>import resources.hk_subsystem;\n\ntask class CHKTask {\n\n    hk_subsystem_port : access IHKSubsystem;\n\n    timer : sink TimeVal triggers hk_timeout;\n\n    action hk_timeout(&amp;priv self, _current_time : TimeVal) -&gt; Status&lt;i32&gt; {\n\n        let status : Status&lt;i32&gt; = Success;\n\n        self-&gt;hk_subsystem_port.update_params();\n        self-&gt;hk_subsystem_port.do_housekeeping();\n\n        return status;\n\n    }\n\n};\n</code></pre> <p>The class <code>CHKTask</code> defines a task type that interacts with the housekeeping subsystem through the access port <code>hk_subsystem_port</code>, which provides access to the <code>IHKSubsystem</code> interface. This port connects the task to the corresponding instance of the <code>CHKSubsystem</code> resource declared in the main application.</p> <p>The field <code>timer</code> is an event sink that receives periodic events from a timer emitter. The declaration <code>sink TimeVal triggers hk_timeout</code> specifies that the task defines an action named <code>hk_timeout</code>, which will be automatically executed whenever the event associated with the timer is received. The parameter <code>_current_time</code> of type TimeVal represents the timestamp of the triggering event, although it is not used in this example.</p> <p>The action <code>hk_timeout()</code> constitutes the main logic of the task. When triggered, it calls the <code>update_params()</code> and <code>do_housekeeping()</code> procedures on the connected housekeeping subsystem. The first procedure updates the system data pool with the latest sensor readings, while the second determines whether it is time to send a housekeeping telemetry packet based on the configured interval. The action returns a value of type <code>Status&lt;i32&gt;</code>, which indicates whether it completed successfully or encountered an error. In this example, it always returns <code>Success</code>. </p> <p>This design clearly demonstrates the reactive execution model of Termina. The task is activated by an external periodic event, performs a bounded sequence of operations within a single action, and interacts exclusively with resources through well-defined interfaces.</p> <p>Once the <code>CHKTask</code> class has been defined in <code>src/tasks/housekeeping.fin</code>, the housekeeping task must be instantiated in the main module <code>app/app.fin</code>. First, import the task module at the top of <code>app/app.fin</code>:</p> Termina <pre><code>import tasks.housekeeping;\n</code></pre> <p>Then add the emitter and task instances at the end of the file:</p> Termina <pre><code>emitter hk_timer : PeriodicTimer = {\n    period = {\n        tv_sec = 1,\n        tv_usec = 0\n    }\n};\n\n#[priority(20)]\ntask hk_task : CHKTask = {\n    hk_subsystem_port &lt;-&gt; hk_subsystem,\n    timer &lt;- hk_timer\n};\n</code></pre> <p>The periodic timer emitter <code>hk_timer</code> serves as the time base that triggers the housekeeping process. It defines an internal field <code>period</code>, which specifies the emission interval using two components: <code>tv_sec</code> and <code>tv_usec</code> for the number of seconds and microseconds, respectively, between consecutive events. In this configuration, the timer generates an event every one second, emulating the periodic activation typical of housekeeping functions in real on-board control systems.</p> <p>The housekeeping task instance <code>hk_task</code> is declared using the <code>CHKTask</code> class. The annotation #[priority(20)] assigns it a fixed scheduling priority of 20. Task priorities determine their relative importance in the system\u2019s scheduling policy and are defined statically at compile time.</p> <p>The task defines two connections. The first binds the task\u2019s access port to the passive housekeeping subsystem resource, allowing the task to invoke its procedures. Through this port, the task calls <code>update_params()</code> and <code>do_housekeeping()</code> on each activation, delegating all data handling and telemetry logic to the subsystem. The second connection links the task\u2019s event sink timer to the periodic emitter <code>hk_timer</code>. This connection ensures that the task\u2019s <code>hk_timeout</code> action is executed automatically each time the timer emits an event. In execution, the periodic timer generates a time event once per second. Each event activates the housekeeping task, which reacts by calling the procedures of the housekeeping subsystem resource.</p>"},{"location":"tutorial/#reading-and-accepting-telecommands","title":"Reading and accepting telecommands","text":"<p>In this final part of the tutorial, we will implement the components responsible for telecommand reception and processing. These include the manager task, which validates received telecommands and issues acknowledgment messages, and the event handler associated with the keyboard interrupt that emulates telecommand input. Additionally, we will define the elements required for dynamic memory management and for the communication between the handler and the manager task.</p>"},{"location":"tutorial/#the-manager-task","title":"The manager task","text":"<p>The manager task acts as the main control process of the application. It is responsible for receiving telecommands from the handler, validating them, and sending the corresponding telemetry reports to acknowledge or reject them. Like all tasks in Termina, it operates reactively: it remains dormant until it receives an event (in this case, a message through a message queue) and then executes its action.</p> <p>The task is defined in the file <code>src/tasks/manager.fin</code>, whose contents are as follows:</p> Termina <pre><code>import resources.tm_channel;\nimport common.types;\nimport lib.accept;\n\ntask class CManagerTask {\n\n    tm_channel_port : access TMChannelInterface;\n    tc_pool_port : access Allocator&lt;TCDescriptor&gt;;\n    in_tc_channel : in box TCDescriptor triggers process_tc;\n\n    action process_tc(&amp;priv self, tc : box TCDescriptor) -&gt; Status&lt;i32&gt; {\n\n        let status : Status&lt;i32&gt; = Success;\n\n        // Process incoming telecommands here\n        var tc_accept : Status&lt;u32&gt; = accept_tc(&amp;tc);\n\n        match tc_accept {\n            case Failure(code) =&gt; {\n                // Telecommand not accepted, send error TM\n                self-&gt;tm_channel_port.send_tm_1_2(code);\n            }\n            case Success =&gt; {\n                // Telecommand accepted, proceed\n                self-&gt;tm_channel_port.send_tm_1_1();\n            }\n        }\n\n        self-&gt;tc_pool_port.free(tc);\n\n        return status;\n\n    }\n\n};\n</code></pre> <p>The <code>CManagerTask</code> class defines three connection ports that link the task to other parts of the system:</p> <ul> <li><code>tm_channel_port</code>: is an access port to the telemetry channel resource, used to send acceptance or error reports after processing each telecommand.</li> <li><code>tc_pool_port</code>: is an access port to the memory pool responsible for managing dynamic memory allocations used to store received telecommands.</li> <li><code>in_tc_channel</code>: is an input message port, declared as <code>in box TCDescriptor</code>, through which the task receives messages containing telecommands encapsulated in dynamically allocated memory blocks. The <code>triggers process_tc</code> clause specifies that the action <code>process_tc()</code> will be executed each time a new message arrives on this port.</li> </ul> <p>The action <code>process_tc()</code> is the core of the task\u2019s behavior. When a telecommand message is received, the runtime passes ownership of the <code>box TCDescriptor</code> object to the action. The task invokes the <code>accept_tc()</code> function, previously defined in the <code>lib.accept</code> module, to determine whether the telecommand is valid. The function returns a <code>Status&lt;u32&gt;</code> value: <code>Success</code> if the telecommand is accepted, or <code>Failure(code)</code> if it is rejected, with an error code of type <code>u32</code>.</p> <p>A match expression is used to handle the two possible cases explicitly:</p> <ul> <li>If the result is <code>Failure(code)</code>, the task calls <code>send_tm_1_2(code)</code> on the telemetry channel to send a telecommand rejection report with the corresponding error code.</li> <li>If the result is <code>Success</code>, the task calls <code>send_tm_1_1()</code> to send a telecommand acceptance report.</li> </ul> <p>Once processing is complete, the task releases the telecommand object by calling <code>self-&gt;tc_pool.free(tc)</code>. This operation returns the dynamically allocated memory block to the memory pool, ensuring that resources are reclaimed deterministically.</p> <p>The action then returns a <code>Status&lt;i32&gt;</code> value indicating the success of its execution. In this example, it always returns <code>Success</code>.</p>"},{"location":"tutorial/#the-keyboard-interrupt-handler","title":"The keyboard interrupt handler","text":"<p>The keyboard interrupt handler is a reactive component that runs whenever input data become available from the standard input stream. In Termina, a handler is an active entity executed immediately in response to an external event, typically an interrupt. Handlers are designed for short, time-critical actions that must execute quickly and deterministically before returning control to the system scheduler.</p> <p>This handler is responsible for simulating the reception of a telecommand through a keyboard interrupt. When triggered, it reads input characters from the console, stores them in a newly allocated telecommand descriptor, and forwards the descriptor to the manager task through a message queue. Dynamic memory allocation and message passing are both performed deterministically using Termina\u2019s memory pools and typed communication channels.</p> <p>The complete implementation of the handler is shown below:</p> Termina <pre><code>import common.types;\n\nhandler class CKbdIRQHandler {\n\n    system_port : access SystemAPI;\n    tc_pool_port : access Allocator&lt;TCDescriptor&gt;;\n    in_kbd_irq : sink u32 triggers receive_tc;\n    tc_channel_out : out box TCDescriptor;\n\n    action receive_tc(&amp;priv self, _vector : u32) -&gt; Status&lt;i32&gt; {\n\n        var status : Status&lt;i32&gt; = Success;\n\n        var opt_tc_desc : Option&lt;box TCDescriptor&gt; = None;\n\n        self-&gt;tc_pool_port.alloc(&amp;mut opt_tc_desc);\n\n        match opt_tc_desc {\n            case Some(tc_desc) =&gt; {\n\n                self-&gt;system_port.read(256, &amp;mut tc_desc.payload, &amp;mut tc_desc.size);\n                if tc_desc.size &gt; 0 {\n                    self-&gt;tc_channel_out.send(tc_desc);\n                } else {\n                    self-&gt;tc_pool_port.free(tc_desc);\n                }\n\n            }\n            case None =&gt; {\n                status = Failure(-1);\n            }\n        }\n\n\n        return status;\n\n    }\n\n};\n</code></pre> <p>The <code>CKbdIRQHandler</code> class defines four ports that connect it to other system components:</p> <ul> <li><code>system_port</code> is an access port to the SystemAPI interface provided by the runtime. It allows the handler to perform system-level operations, such as reading input from the standard input buffer.</li> <li><code>tc_pool_port</code> is an access port to the memory pool that manages the dynamic allocation of telecommand descriptors.</li> <li><code>kbd_irq_in</code> is an event sink that receives interrupts whenever data become available in the standard input buffer. Each interrupt triggers the <code>receive_tc()</code> action.</li> <li><code>tc_channel_out</code> is an output message port used to send the telecommand descriptor to the manager task via a message queue. The action <code>receive_tc()</code> implements the logic executed upon each interrupt. It first attempts to allocate a new telecommand descriptor from the memory pool. The allocation result is stored in an <code>Option&lt;box TCDescriptor&gt;</code>, which enforces explicit handling of success or failure cases:</li> <li>If allocation succeeds (<code>Some(tc_desc)</code>), the handler reads up to 256 characters from the system input into the descriptor\u2019s payload field and stores the number of valid characters in size.</li> <li>If the telecommand contains data, the descriptor is sent through <code>tc_channel_out</code> to the manager task.</li> <li>If no data are read, the allocated memory is released back to the pool using <code>free()</code>.</li> </ul> <p>If allocation fails (<code>None</code>), the action sets the status to <code>Failure(-1)</code> and exits. </p> <p>Finally, the action returns a <code>Status&lt;i32&gt;</code> value, which in this example is always <code>Success</code> unless a memory allocation error occurs.</p>"},{"location":"tutorial/#deploying-the-remaining-components","title":"Deploying the remaining components","text":"<p>Once the keyboard interrupt handler has been implemented, the last step is to instantiate the remaining system elements that complete the application\u2019s architecture.</p> <p>The event corresponding to the keyboard interrupt is generated by a runtime-provided emitter. As with the system call interface, this emitter is not deployed automatically. To enable it, a configuration parameter must be added to the project\u2019s termina.yaml file. Specifically, the following lines must be included at the end of the configuration file:</p> YAML <pre><code>platform-flags:\nposix-gcc:\n    enable-kbd-irq: true\n</code></pre> <p>This directive instructs the runtime to deploy the kbd_irq emitter, which generates an event if there are characters stored in the standard input buffer. This emitter will act as the trigger for the keyboard interrupt handler, allowing the system to simulate telecommand reception.</p> <p>With the emitter available, we can now deploy the remaining elements required to complete the communication path between the handler and the manager task:</p> <ul> <li>The telecommand descriptor pool (<code>tc_pool</code>), which manages the dynamic allocation of <code>TCDescriptor</code> objects used to store incoming telecommands. The pool will contain 10 preallocated elements.</li> <li>The message queue (<code>tc_channel</code>), which provides the communication channel between the handler and the manager task. It also has a capacity of 10 elements, ensuring bounded buffering of telecommands.</li> <li>The keyboard interrupt handler (<code>kbd_handler</code>), which listens for keyboard events, reads input from the console, and forwards telecommands to the manager task through the message queue.</li> <li>The manager task (<code>manager_task</code>), which processes received telecommands, validates them, and issues the appropriate telemetry acknowledgment.</li> </ul> <p>All of these elements are instantiated in the main application module <code>app/app.fin</code>. Before doing so, we must include the following imports at the beginning of the file:</p> Termina <pre><code>import tasks.housekeeping;\nimport tasks.manager;\nimport handlers.kbdhandler;\n</code></pre> <p>Once the modules have been imported, we can now add the remaining elements at the end of the file:</p> Termina <pre><code>resource tc_pool : Pool&lt;TCDescriptor; 10&gt;;\n\nchannel tc_channel : MsgQueue&lt;box TCDescriptor; 10&gt;;\n\nhandler kbd_handler : CKbdIRQHandler = {\n    system_port &lt;-&gt; system_entry,\n    in_kbd_irq &lt;- kbd_irq,\n    tc_pool_port &lt;-&gt; tc_pool,\n    tc_channel_out -&gt; tc_channel\n};\n\n#[priority(10: u32)]\ntask manager_task : CManagerTask = {\n    tm_channel_port &lt;-&gt; tm_channel,\n    tc_pool_port &lt;-&gt; tc_pool,\n    in_tc_channel &lt;- tc_channel\n};\n</code></pre> <p>This code performs the following actions:</p> <ul> <li>The memory pool <code>tc_pool</code> is instantiated to manage dynamic allocations of telecommand descriptors.</li> <li>The message queue <code>tc_channel</code> is created to enable asynchronous communication between the interrupt handler and the manager task.</li> <li>The keyboard interrupt handler <code>kbd_handler</code> connects its ports to the relevant components:<ul> <li><code>system_port</code> connects to <code>system_entry</code>, giving the handler access to system calls for reading input data.</li> <li><code>kbd_irq_in</code> is connected to the <code>kbd_irq</code> emitter, which triggers the interrupt events generated by the runtime.</li> <li><code>tc_pool_port</code> links to the memory pool for descriptor allocation and deallocation.</li> <li><code>tc_channel_out</code> is connected to the telecommand message queue, enabling communication with the manager task.</li> </ul> </li> <li>The manager task <code>manager_task</code> is instantiated with a priority of 10. It connects its ports as follows:<ul> <li><code>tm_channel_port</code> links to the telemetry channel resource for sending acknowledgment packets.</li> <li><code>tc_pool_port</code> links to the memory pool, allowing it to free processed telecommand descriptors.</li> <li><code>tc_channel_in</code> connects to the telecommand message queue to receive incoming messages from the handler.</li> </ul> </li> </ul> <p>After these elements are deployed, the application architecture is complete.</p>"},{"location":"tutorial/#building-and-running-the-application","title":"Building and Running the Application","text":"<p>With all the modules and configuration files in place, the project is now ready to be built and executed. This final stage of the tutorial demonstrates how to compile the Termina application, generate the corresponding C code, and run the executable on the POSIX platform to observe its behavior.</p>"},{"location":"tutorial/#project-structure","title":"Project structure","text":"<p>Before building, the project directory should have the following structure:</p> <pre><code>icusw_demo/\n\u251c\u2500\u2500 termina.yaml\n\u251c\u2500\u2500 app/\n\u2502   \u2514\u2500\u2500 app.fin\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 common/\n\u2502   \u2502   \u2514\u2500\u2500 types.fin\n\u2502   \u251c\u2500\u2500 lib/\n\u2502   \u2502   \u2514\u2500\u2500 accept.fin\n\u2502   \u251c\u2500\u2500 handlers/\n\u2502   \u2502   \u2514\u2500\u2500 kbdhandler.fin\n\u2502   \u251c\u2500\u2500 resources/\n\u2502   \u2502   \u251c\u2500\u2500 hk_subsystem.fin\n\u2502   \u2502   \u251c\u2500\u2500 sensor_array.fin\n\u2502   \u2502   \u251c\u2500\u2500 sys_data_pool.fin\n\u2502   \u2502   \u2514\u2500\u2500 tm_channel.fin\n\u2502   \u2514\u2500\u2500 tasks/\n\u2502       \u251c\u2500\u2500 housekeeping.fin\n\u2502       \u2514\u2500\u2500 manager.fin\n\u2514\u2500\u2500 output/\n</code></pre>"},{"location":"tutorial/#building-the-project","title":"Building the project","text":"<p>Once the directory structure is complete, we must open a terminal in the project\u2019s root directory (<code>icusw_demo/</code>) and execute the Termina build command:</p> <pre><code>$ termina build\n</code></pre> <p>The <code>termina build</code> command invokes the Termina transpiler, which translates all .fin source modules into C code. During this process, it validates the program structure, checks type safety, verifies all port connections, and generates the necessary runtime configuration for the selected platform. The resulting C files are placed automatically in the output/ directory.</p> <p>If the transpilation process completes successfully, you can compile the generated C code using the standard build system provided with the <code>posix-gcc</code> platform. To do this, enter the following commands:</p> <pre><code>$ cd output\n$ make\n</code></pre> <p>This command sequence invokes the GCC compiler with the build rules generated by the transpiler. After a successful compilation, a new executable binary will be created in the <code>bin/</code> directory:</p> <pre><code>icusw_demo/\n.\n\u2514\u2500\u2500 output/\n    \u251c\u2500\u2500 bin/\n    \u2502   \u2514\u2500\u2500 icusw_demo\n    \u251c\u2500\u2500 Makefile\n    \u2514\u2500\u2500 src/  (generated C code)\n</code></pre>"},{"location":"tutorial/#running-the-application","title":"Running the application","text":"<p>To run the demo, execute the binary from the console:</p> <pre><code>$ ./bin/icusw_demo\n</code></pre> <p>Once launched, the program initializes the runtime and deploys all defined resources, tasks, and handlers. You can now interact with the application directly through the terminal:</p> <ul> <li>Type any string in the console and press Enter to simulate the reception of a telecommand.<ul> <li>If the telecommand starts with the letter v, it will be accepted, and the system will print a message corresponding to TM(1,1).</li> <li>If it starts with e, it will be rejected with error code 0, producing TM(1,2).</li> <li>Any other string will be rejected with error code 1.</li> </ul> </li> <li>In parallel, the housekeeping task executes periodically (once per second), invoking the housekeeping subsystem to collect synthetic sensor values and generate housekeeping telemetry packets. You will see output messages similar to:</li> </ul> <pre><code>Send TM(3,25): 1939973050, 1222863988, 1351162014, 1328756915, 1352917968, 2111677371, 1334411258, 575130578, 1606705543, 1606250631\n</code></pre> <p>Each line corresponds to a housekeeping telemetry report containing the ten simulated sensor readings currently stored in the system data pool.</p>"},{"location":"basics/functions/","title":"Functions","text":"<p>In Termina, functions are the fundamental units of computation. They let you break a program into smaller, reusable pieces of logic. Every function in Termina runs to completion: it starts with its inputs, performs a computation, and produces a result.</p> <p>A function can only access its input parameters and global constants. It cannot read or modify global mutable state. This strict limitation makes functions deterministic and easy to analyze. If a function modifies something, it must be through an explicit reference parameter, so side effects are always visible in the function\u2019s signature.</p>"},{"location":"basics/functions/#defining-a-function","title":"Defining a Function","text":"<p>A function begins with the keyword <code>function</code>, followed by its name, parameter list, and return type:</p> TerminaC <pre><code>function add(a: i32, b: i32) -&gt; i32 {\n\n    return a + b;\n\n}\n</code></pre> <pre><code>int32_t add(int32_t a, int32_t b) {\n\n    return a + b;\n\n}\n</code></pre> <p>Here, the function <code>add</code> takes two integers and returns their sum.</p>"},{"location":"started/hello-world/","title":"Hello, Real-Time World!","text":"<p>The transpilation tool, in addition to performing code translation, is used to create new Termina projects. Thus, the tool supports different commands. In particular, the <code>new</code> command allows you to create a new project containing an initial directory tree and a project configuration file with default parameters.</p> <p>In our case, we are going to create a new project named <code>hello_world</code>. To do this, we will execute the following command from the terminal:</p> <pre><code>$ termina new hello_world\n</code></pre> <p>After executing the command, a new directory called <code>hello_world</code> containing the following elements will have been generated:</p> <pre><code>hello_world\n    termina.yaml\n    app/app.fin\n    src\n    output\n</code></pre> <p>The file <code>termina.yaml</code> stores the project configuration parameters. The <code>app</code> directory contains the main Termina source code file of the application. By default, this file is named <code>app.fin</code>. The <code>src</code> directory will contain the additional modules that are part of the project. In our case, we will not add any files to this directory. The <code>output</code> directory will store the files generated by the transpiler from the Termina code.</p> <p>Next, we are going to modify the <code>app.fin</code> file, adding the following content:</p> <pre><code>task class HelloWorldClass {\n\n    timer_port : sink TimeVal triggers timeout;\n\n    system_port : access SystemAPI;\n\n    action timeout(&amp;priv self, _current_time : TimeVal) -&gt; Status&lt;i32&gt; {\n\n        let msg : [char; 128] = \"Hello, Real-Time World!\";\n        let ret : Status&lt;i32&gt; = Success;\n\n        self-&gt;system_port.println(128, &amp;msg);\n\n        return ret;\n\n    }\n\n};\n\nemitter timer : PeriodicTimer = {\n    period = {\n        tv_sec = 1,\n        tv_usec = 0\n    }\n};\n\n#[priority(10)]\ntask hello_world_task : HelloWorldClass = {\n\n    timer_port &lt;- timer,\n    system_port &lt;-&gt; system_entry\n\n};\n</code></pre> <p>The next step is to update the <code>termina.yaml</code> configuration file, where we will need to add the following line at the end:</p> <pre><code>enable-system-port: true\n</code></pre> <p>Finally, we will generate the application code with the following commands:</p> <pre><code>$ termina build\n</code></pre> <p>If the command has been executed successfully, the <code>output</code> directory should contain the modules resulting from the transpilation. In order to compile and run the project, we will have to execute the following commands in the terminal:</p> <pre><code>$ cd output\n$ make\n$ ./bin/hello_world\n</code></pre> <p>The program will print the message \u201cHello, Real-Time World!\u201d on the screen every second. To exit, it will be necessary to interrupt the execution of the program by entering the key combination <code>Ctrl+C</code> in the terminal.</p>"},{"location":"started/install/","title":"Installation","text":"<p>To install the Termina to C transpiler it is necessary to compile the project directly from the source code. Unfortunately, binary releases are not available yet. To compile the project, it is first necessary to install the Stack tool. The Stack installation instructions can be found through this link.</p> <p>Once Stack is installed, you can proceed to clone the repository and then compile the project. To do this, you need to execute the following commands:</p> <pre><code>$ git clone https://github.com/termina-lang/termina\n$ cd termina\n$ stack init\n$ stack install\n</code></pre> <p>The first <code>stack</code> command will initialize the repository and generate the configuration files needed to compile the project. The second one allows you to compile the project and install the binary in a specific directory so that it is accessible for execution.</p> <p>In order to execute the code generated by the transpiler, it is necessary to install the Termina Operating System Abstraction Layer found in this repository.</p> <p>By default, the installation path of the Termina OSAL expected by the standard project compilation mechanism is the <code>/opt</code> directory. However, it is possible to modify the default path specifically for each project.</p> <p>In the following paragraphs, we will clone the Termina OSAL project and then create a symbolic link to the project directory within the <code>/opt</code> directory. To do this, it is necessary to execute the following commands:</p> <pre><code>$ git clone https://github.com/termina-lang/termina-osal\n$ cd /opt\n$ sudo ln -s /path/to/termina-osal\n</code></pre> <p>where <code>/path/to/termina-osal</code> must point to the actual path corresponding to the cloned repository.</p>"}]}